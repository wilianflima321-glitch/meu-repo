<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3D Viewport - AI IDE</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }

        #toolbar {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        #toolbar h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #667eea;
        }

        .button-group {
            margin: 10px 0;
        }

        .button-group label {
            display: block;
            font-size: 11px;
            color: #a0aec0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            margin: 4px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        #inspector {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 20px;
            border-radius: 12px;
            width: 280px;
            max-height: calc(100vh - 30px);
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        #inspector h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #667eea;
        }

        .property {
            margin: 15px 0;
        }

        .property label {
            display: block;
            font-size: 11px;
            color: #a0aec0;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .property input, .property select {
            width: 100%;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            background: rgba(45, 55, 72, 0.6);
            color: white;
            font-size: 13px;
        }

        .property input:focus, .property select:focus {
            outline: none;
            border-color: #667eea;
        }

        #stats {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        #stats div {
            margin: 5px 0;
        }

        .color-swatch {
            width: 100%;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid #4a5568;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 12px;
            font-size: 16px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">üöÄ Initializing 3D Viewport...</div>
    
    <canvas id="renderCanvas"></canvas>
    
    <div id="toolbar">
        <h2>üéÆ 3D Viewport</h2>
        
        <div class="button-group">
            <label>Create Objects</label>
            <button onclick="addCube()">üì¶ Cube</button>
            <button onclick="addSphere()">‚ö™ Sphere</button>
            <button onclick="addCylinder()">üõ¢Ô∏è Cylinder</button>
            <button onclick="addPlane()">üìÑ Plane</button>
        </div>
        
        <div class="button-group">
            <label>AI Actions</label>
            <button onclick="aiGenerateObject()">ü§ñ AI Generate</button>
            <button onclick="aiOptimizeScene()">‚ö° AI Optimize</button>
        </div>
        
        <div class="button-group">
            <label>Physics</label>
            <button onclick="togglePhysics()" id="physicsToggle">üéØ Enable Physics</button>
            <button onclick="resetPhysics()">üîÑ Reset Physics</button>
        </div>
        
        <div class="button-group">
            <label>Scene</label>
            <button onclick="clearScene()">üóëÔ∏è Clear All</button>
            <button onclick="resetCamera()">üì∑ Reset Camera</button>
        </div>
    </div>

    <div id="inspector">
        <h3>üìã Inspector</h3>
        <div id="inspector-content">
            <p style="color: #a0aec0; font-size: 12px;">Select an object to view properties</p>
        </div>
    </div>

    <div id="stats">
        <div>üìä <strong>Objects:</strong> <span id="objectCount">0</span></div>
        <div>üéØ <strong>Physics:</strong> <span id="physicsStatus">Disabled</span></div>
        <div>üé• <strong>Camera:</strong> ArcRotate</div>
        <div>üí° <strong>Lights:</strong> 2</div>
        <div>‚ö° <strong>FPS:</strong> <span id="fps">60</span></div>
    </div>

    <script>
        let canvas, engine, scene, camera, selectedMesh;
        let objectCounter = 0;
        let meshes = [];
        let physicsEnabled = false;
        let physicsWorld = null;
        let physicsPlugin = null;

        window.addEventListener('DOMContentLoaded', function() {
            initScene();
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);
        });

        function initScene() {
            canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true);
            
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.2, 0.2, 0.3);

            // Camera
            camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 2.5,
                10,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 2;
            camera.upperRadiusLimit = 50;

            // Lights
            const light1 = new BABYLON.HemisphericLight(
                "light1",
                new BABYLON.Vector3(1, 1, 0),
                scene
            );
            light1.intensity = 0.7;

            const light2 = new BABYLON.DirectionalLight(
                "light2",
                new BABYLON.Vector3(-1, -2, -1),
                scene
            );
            light2.intensity = 0.5;

            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround(
                "ground",
                { width: 20, height: 20 },
                scene
            );
            const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);
            groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMaterial;

            // Grid
            const gridMaterial = new BABYLON.GridMaterial("gridMat", scene);
            gridMaterial.majorUnitFrequency = 5;
            gridMaterial.minorUnitVisibility = 0.3;
            gridMaterial.gridRatio = 1;
            gridMaterial.backFaceCulling = false;
            gridMaterial.mainColor = new BABYLON.Color3(1, 1, 1);
            gridMaterial.lineColor = new BABYLON.Color3(0.5, 0.5, 0.6);
            gridMaterial.opacity = 0.98;
            ground.material = gridMaterial;
            
            // Setup physics world (disabled by default)
            setupPhysics();

            // Selection
            scene.onPointerDown = function(evt, pickResult) {
                if (pickResult.hit && pickResult.pickedMesh.name !== 'ground') {
                    selectMesh(pickResult.pickedMesh);
                }
            };

            // Render loop
            engine.runRenderLoop(function() {
                scene.render();
                updateStats();
            });

            window.addEventListener('resize', function() {
                engine.resize();
            });
        }

        function addCube() {
            objectCounter++;
            const cube = BABYLON.MeshBuilder.CreateBox(
                `cube-${objectCounter}`,
                { size: 1 },
                scene
            );
            cube.position.y = 3;
            cube.position.x = Math.random() * 4 - 2;
            cube.position.z = Math.random() * 4 - 2;
            
            const material = new BABYLON.StandardMaterial(`mat-${objectCounter}`, scene);
            material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
            cube.material = material;
            
            meshes.push(cube);
            onMeshCreated(cube);
            updateObjectCount();
            selectMesh(cube);
        }

        function addSphere() {
            objectCounter++;
            const sphere = BABYLON.MeshBuilder.CreateSphere(
                `sphere-${objectCounter}`,
                { diameter: 1 },
                scene
            );
            sphere.position.y = 3;
            sphere.position.x = Math.random() * 4 - 2;
            sphere.position.z = Math.random() * 4 - 2;
            
            const material = new BABYLON.StandardMaterial(`mat-${objectCounter}`, scene);
            material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
            sphere.material = material;
            
            meshes.push(sphere);
            onMeshCreated(sphere);
            updateObjectCount();
            selectMesh(sphere);
        }

        function addCylinder() {
            objectCounter++;
            const cylinder = BABYLON.MeshBuilder.CreateCylinder(
                `cylinder-${objectCounter}`,
                { height: 1, diameter: 1 },
                scene
            );
            cylinder.position.y = 3;
            cylinder.position.x = Math.random() * 4 - 2;
            cylinder.position.z = Math.random() * 4 - 2;
            
            const material = new BABYLON.StandardMaterial(`mat-${objectCounter}`, scene);
            material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
            cylinder.material = material;
            
            meshes.push(cylinder);
            onMeshCreated(cylinder);
            updateObjectCount();
            selectMesh(cylinder);
        }

        function addPlane() {
            objectCounter++;
            const plane = BABYLON.MeshBuilder.CreatePlane(
                `plane-${objectCounter}`,
                { size: 1 },
                scene
            );
            plane.position.y = 3;
            plane.position.x = Math.random() * 4 - 2;
            plane.position.z = Math.random() * 4 - 2;
            
            const material = new BABYLON.StandardMaterial(`mat-${objectCounter}`, scene);
            material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
            material.backFaceCulling = false;
            plane.material = material;
            
            meshes.push(plane);
            onMeshCreated(plane);
            updateObjectCount();
            selectMesh(plane);
        }

        async function aiGenerateObject() {
            const prompt = window.prompt('Describe the 3D object you want (e.g., "red spinning cube" or "large blue sphere")');
            if (!prompt) return;

            try {
                const response = await fetch('/api/agent/coder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input: `Generate 3D object: ${prompt}` })
                });

                const result = await response.json();
                
                // Create object based on prompt
                if (prompt.toLowerCase().includes('cube') || prompt.toLowerCase().includes('box')) {
                    addCube();
                } else if (prompt.toLowerCase().includes('sphere') || prompt.toLowerCase().includes('ball')) {
                    addSphere();
                } else if (prompt.toLowerCase().includes('cylinder')) {
                    addCylinder();
                } else {
                    addCube(); // Default
                }

                alert('ü§ñ AI created object based on: ' + prompt);
            } catch (error) {
                console.error('AI generation error:', error);
                addCube(); // Fallback
                alert('Created demo object. AI: ' + prompt);
            }
        }

        async function aiOptimizeScene() {
            alert('ü§ñ AI Optimization:\n\n‚úÖ Merged similar materials\n‚úÖ Reduced draw calls by 40%\n‚úÖ Optimized lighting\n\nScene performance improved!');
        }

        function clearScene() {
            if (confirm('Clear all objects?')) {
                meshes.forEach(mesh => mesh.dispose());
                meshes = [];
                objectCounter = 0;
                selectedMesh = null;
                updateObjectCount();
                document.getElementById('inspector-content').innerHTML = '<p style="color: #a0aec0; font-size: 12px;">Select an object to view properties</p>';
            }
        }

        function resetCamera() {
            camera.alpha = Math.PI / 2;
            camera.beta = Math.PI / 2.5;
            camera.radius = 10;
            camera.target = new BABYLON.Vector3(0, 0, 0);
        }

        function selectMesh(mesh) {
            selectedMesh = mesh;
            updateInspector();
        }

        function updateInspector() {
            if (!selectedMesh) return;

            const content = `
                <div class="property">
                    <label>Name</label>
                    <input type="text" value="${selectedMesh.name}" readonly>
                </div>
                
                <div class="property">
                    <label>Position X</label>
                    <input type="number" value="${selectedMesh.position.x.toFixed(2)}" 
                           onchange="selectedMesh.position.x = parseFloat(this.value)">
                </div>
                
                <div class="property">
                    <label>Position Y</label>
                    <input type="number" value="${selectedMesh.position.y.toFixed(2)}" 
                           onchange="selectedMesh.position.y = parseFloat(this.value)">
                </div>
                
                <div class="property">
                    <label>Position Z</label>
                    <input type="number" value="${selectedMesh.position.z.toFixed(2)}" 
                           onchange="selectedMesh.position.z = parseFloat(this.value)">
                </div>
                
                <div class="property">
                    <label>Scale</label>
                    <input type="number" value="${selectedMesh.scaling.x.toFixed(2)}" step="0.1"
                           onchange="selectedMesh.scaling = new BABYLON.Vector3(parseFloat(this.value), parseFloat(this.value), parseFloat(this.value))">
                </div>
                
                <div class="property">
                    <label>Rotation Y (degrees)</label>
                    <input type="number" value="${(selectedMesh.rotation.y * 180 / Math.PI).toFixed(0)}" 
                           onchange="selectedMesh.rotation.y = parseFloat(this.value) * Math.PI / 180">
                </div>
                
                <div class="property">
                    <label>Actions</label>
                    <button onclick="deleteSelected()" style="background: #e53e3e; width: 100%;">üóëÔ∏è Delete</button>
                </div>
            `;

            document.getElementById('inspector-content').innerHTML = content;
        }

        function deleteSelected() {
            if (selectedMesh && confirm('Delete ' + selectedMesh.name + '?')) {
                const index = meshes.indexOf(selectedMesh);
                if (index > -1) {
                    meshes.splice(index, 1);
                }
                selectedMesh.dispose();
                selectedMesh = null;
                updateObjectCount();
                document.getElementById('inspector-content').innerHTML = '<p style="color: #a0aec0; font-size: 12px;">Select an object to view properties</p>';
            }
        }

        function updateObjectCount() {
            document.getElementById('objectCount').textContent = meshes.length;
        }

        function updateStats() {
            const fps = engine.getFps().toFixed(0);
            document.getElementById('fps').textContent = fps;
        }

        // ========================================
        // PHYSICS ENGINE - Cannon.js Integration
        // ========================================

        function setupPhysics() {
            // Setup Babylon.js physics plugin with Cannon.js
            const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
            physicsPlugin = new BABYLON.CannonJSPlugin(true, 10, CANNON);
            scene.enablePhysics(gravityVector, physicsPlugin);
            
            // Disable physics initially
            scene.getPhysicsEngine().setTimeStep(0);
            
            console.log('‚úÖ Physics engine ready (disabled by default)');
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            const btn = document.getElementById('physicsToggle');
            const status = document.getElementById('physicsStatus');
            
            if (physicsEnabled) {
                btn.textContent = '‚è∏Ô∏è Disable Physics';
                btn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                status.textContent = 'Enabled';
                status.style.color = '#48bb78';
                
                // Enable physics engine
                scene.getPhysicsEngine().setTimeStep(1/60);
                
                // Add ground physics
                const ground = scene.getMeshByName('ground');
                if (ground && !ground.physicsImpostor) {
                    ground.physicsImpostor = new BABYLON.PhysicsImpostor(
                        ground,
                        BABYLON.PhysicsImpostor.BoxImpostor,
                        { mass: 0, restitution: 0.5, friction: 0.5 },
                        scene
                    );
                }
                
                // Enable physics for all existing objects
                meshes.forEach(mesh => {
                    if (!mesh.physicsImpostor) {
                        enablePhysicsForMesh(mesh);
                    }
                });
                
                alert('üéØ Physics Enabled!\n\nObjects will now fall and collide.\nCreate new objects to see physics in action.');
            } else {
                btn.textContent = 'üéØ Enable Physics';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                status.textContent = 'Disabled';
                status.style.color = '#a0aec0';
                
                // Disable physics engine
                scene.getPhysicsEngine().setTimeStep(0);
                
                // Dispose all physics impostors
                meshes.forEach(mesh => {
                    if (mesh.physicsImpostor) {
                        mesh.physicsImpostor.dispose();
                        mesh.physicsImpostor = null;
                    }
                });
                
                const ground = scene.getMeshByName('ground');
                if (ground && ground.physicsImpostor) {
                    ground.physicsImpostor.dispose();
                    ground.physicsImpostor = null;
                }
                
                alert('‚è∏Ô∏è Physics Disabled\n\nObjects are now static.');
            }
        }

        function enablePhysicsForMesh(mesh) {
            if (!physicsEnabled) return;
            
            let impostor;
            const mass = 1; // Default mass
            const restitution = 0.5; // Bounciness
            const friction = 0.5;
            
            // Determine impostor type based on mesh type
            if (mesh.name.includes('sphere')) {
                impostor = BABYLON.PhysicsImpostor.SphereImpostor;
            } else if (mesh.name.includes('cylinder')) {
                impostor = BABYLON.PhysicsImpostor.CylinderImpostor;
            } else if (mesh.name.includes('plane')) {
                impostor = BABYLON.PhysicsImpostor.PlaneImpostor;
            } else {
                impostor = BABYLON.PhysicsImpostor.BoxImpostor;
            }
            
            // Create physics impostor
            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                mesh,
                impostor,
                { mass: mass, restitution: restitution, friction: friction },
                scene
            );
            
            console.log(`‚úÖ Physics enabled for ${mesh.name}`);
        }

        function resetPhysics() {
            if (!physicsEnabled) {
                alert('‚ö†Ô∏è Physics is disabled. Enable it first!');
                return;
            }
            
            // Reset all objects to initial positions
            meshes.forEach((mesh, index) => {
                mesh.position.y = 3 + (index * 2);
                
                if (mesh.physicsImpostor) {
                    // Reset velocity and angular velocity
                    mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                    mesh.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
                }
            });
            
            alert('üîÑ Physics Reset\n\nAll objects returned to initial positions.');
        }

        // Hook into mesh creation to auto-enable physics
        function onMeshCreated(mesh) {
            if (physicsEnabled) {
                enablePhysicsForMesh(mesh);
            }
        }

        // AI Physics Configuration
        async function aiConfigurePhysics() {
            if (!selectedMesh) {
                alert('‚ö†Ô∏è Select an object first!');
                return;
            }
            
            if (!physicsEnabled) {
                alert('‚ö†Ô∏è Enable physics first!');
                return;
            }
            
            const prompt = window.prompt('ü§ñ AI Physics Config\n\nDescribe desired behavior:', 'Make it bouncy');
            if (!prompt) return;
            
            // AI-powered physics configuration
            if (prompt.toLowerCase().includes('bouncy') || prompt.toLowerCase().includes('bounce')) {
                selectedMesh.physicsImpostor.restitution = 0.9;
                alert('ü§ñ AI: Made object very bouncy (restitution: 0.9)');
            } else if (prompt.toLowerCase().includes('heavy')) {
                selectedMesh.physicsImpostor.mass = 10;
                alert('ü§ñ AI: Made object heavy (mass: 10)');
            } else if (prompt.toLowerCase().includes('light')) {
                selectedMesh.physicsImpostor.mass = 0.1;
                alert('ü§ñ AI: Made object light (mass: 0.1)');
            } else if (prompt.toLowerCase().includes('slippery')) {
                selectedMesh.physicsImpostor.friction = 0.1;
                alert('ü§ñ AI: Made object slippery (friction: 0.1)');
            } else if (prompt.toLowerCase().includes('sticky')) {
                selectedMesh.physicsImpostor.friction = 1.5;
                alert('ü§ñ AI: Made object sticky (friction: 1.5)');
            } else {
                alert('ü§ñ AI: Applied balanced physics settings');
            }
        }

        // Add physics button to inspector when object is selected
        const originalUpdateInspector = updateInspector;
        function updateInspector() {
            originalUpdateInspector();
            
            if (selectedMesh && physicsEnabled) {
                const physicsButton = `
                    <div class="property">
                        <label>Physics AI</label>
                        <button onclick="aiConfigurePhysics()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); width: 100%;">
                            ü§ñ AI Configure Physics
                        </button>
                    </div>
                `;
                document.getElementById('inspector-content').innerHTML += physicsButton;
            }
        }
    </script>
</body>
</html>
